/**
 * gifwrap.min.js - UMD封装
 */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD
    define(['omggif'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // Node.js
    module.exports = factory(require('omggif'));
  } else {
    // Browser globals
    root.gifwrap = factory(root.omggif);
  }
}(typeof self !== 'undefined' ? self : this, function (omggif) {
  'use strict';

  // 基本类定义
  class GifFrame {
    constructor(dimensions, pixels, options = {}) {
      this.dimensions = dimensions || { width: 0, height: 0 };
      this.pixels = pixels || null;
      this.disposalMethod = options.disposalMethod || 0;
      this.delayCentisecs = options.delayCentisecs || 10;
      this.interlaced = options.interlaced || false;
    }
  }

  class GifUtil {
    static frameToImageData(frame, existingImageData, options = {}) {
      return new Promise((resolve) => {
        const width = options.width || frame.dimensions.width;
        const height = options.height || frame.dimensions.height;
        
        // 创建ImageData
        let imageData;
        if (existingImageData) {
          imageData = existingImageData;
        } else if (typeof ImageData !== 'undefined') {
          imageData = new ImageData(width, height);
        } else {
          // 创建兼容的ImageData
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          imageData = ctx.createImageData(width, height);
        }
        
        // 复制像素数据
        const data = imageData.data;
        const pixels = frame.pixels;
        
        for (let i = 0; i < pixels.length; i += 4) {
          data[i] = pixels[i];     // R
          data[i+1] = pixels[i+1]; // G
          data[i+2] = pixels[i+2]; // B
          data[i+3] = pixels[i+3]; // A
        }
        
        resolve(imageData);
      });
    }
  }

  class GifCodec {
    constructor(options = {}) {
      this.options = options;
    }
    
    async decodeGif(buffer) {
      return new Promise((resolve, reject) => {
        try {
          // 使用omggif解码GIF
          const arrayBuffer = buffer instanceof ArrayBuffer ? buffer : new Uint8Array(buffer).buffer;
          // 检查omggif的结构，适配不同的导出方式
          const GifReader = typeof omggif === 'function' ? omggif : omggif.GifReader;
          const gif = new GifReader(new Uint8Array(arrayBuffer));
          
          const width = gif.width;
          const height = gif.height;
          const frameCount = gif.numFrames();
          const frames = [];
          
          for (let i = 0; i < frameCount; i++) {
            const frameInfo = gif.frameInfo(i);
            const pixels = new Uint8Array(width * height * 4);
            
            // 解码帧
            gif.decodeAndBlitFrameRGBA(i, pixels);
            
            // 创建帧对象
            frames.push(new GifFrame(
              { width, height },
              pixels,
              {
                delayCentisecs: frameInfo.delay || 10,
                disposalMethod: frameInfo.disposal || 0,
                interlaced: frameInfo.interlaced || false
              }
            ));
          }
          
          resolve({
            width,
            height,
            frames,
            loops: gif.loopCount()
          });
        } catch (error) {
          reject(error);
        }
      });
    }
    
    async encodeGif(frames, options = {}) {
      return new Promise((resolve, reject) => {
        try {
          if (!frames || frames.length === 0) {
            reject(new Error('No frames to encode'));
            return;
          }
          
          // 获取第一帧的尺寸
          const firstFrame = frames[0];
          const width = firstFrame.dimensions.width;
          const height = firstFrame.dimensions.height;
          
          // 创建GIF编码器
          // 检查omggif的结构，适配不同的导出方式
          const GifWriter = typeof omggif === 'function' ? omggif : omggif.GifWriter;
          const gif = new GifWriter(new Uint8Array(1024 * 1024 * 10), width, height, {
            loop: options.loops !== undefined ? options.loops : 0
          });
          
          // 编码每一帧
          for (let i = 0; i < frames.length; i++) {
            const frame = frames[i];
            const pixels = frame.pixels;
            
            // 添加帧
            gif.addFrame(0, 0, width, height, pixels, {
              delay: frame.delayCentisecs || 10,
              disposal: frame.disposalMethod || 0,
              transparent: options.transparentColor !== undefined ? options.transparentColor : null
            });
          }
          
          // 获取编码后的数据
          const buffer = gif.end();
          const finalBuffer = buffer.subarray(0, gif.end());
          
          resolve({
            buffer: finalBuffer.buffer,
            byteLength: finalBuffer.byteLength
          });
        } catch (error) {
          reject(error);
        }
      });
    }
  }

  // 导出
  return {
    GifFrame,
    GifUtil,
    GifCodec
  };
})); 