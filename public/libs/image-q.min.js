/**
 * image-q.min.js - UMD封装
 * 图像量化库的简化版本
 */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD
    define([], factory);
  } else if (typeof module === 'object' && module.exports) {
    // Node.js
    module.exports = factory();
  } else {
    // Browser globals
    root.imageQ = factory();
  }
}(typeof self !== 'undefined' ? self : this, function () {
  'use strict';

  // 简化版本的image-q库
  const imageQ = {
    // 基本颜色量化功能
    quantize: function(pixels, maxColors) {
      return {
        palette: createPalette(maxColors || 256),
        indexedPixels: createIndexedPixels(pixels, maxColors || 256)
      };
    },
    
    // 调色板生成
    buildPalette: function(pixels, maxColors) {
      return createPalette(maxColors || 256);
    }
  };
  
  // 创建一个简单的调色板
  function createPalette(maxColors) {
    const palette = [];
    const step = Math.ceil(256 / Math.pow(maxColors, 1/3));
    
    for (let r = 0; r < 256; r += step) {
      for (let g = 0; g < 256; g += step) {
        for (let b = 0; b < 256; b += step) {
          if (palette.length < maxColors) {
            palette.push({
              r: Math.min(r, 255),
              g: Math.min(g, 255),
              b: Math.min(b, 255),
              a: 255
            });
          }
        }
      }
    }
    
    // 确保有透明色
    if (palette.length < maxColors) {
      palette.push({
        r: 0,
        g: 0,
        b: 0,
        a: 0
      });
    }
    
    return palette;
  }
  
  // 创建索引像素
  function createIndexedPixels(pixels, maxColors) {
    if (!pixels || pixels.length === 0) return new Uint8Array(0);
    
    const length = pixels.length / 4;
    const indexedPixels = new Uint8Array(length);
    
    for (let i = 0; i < length; i++) {
      // 简单的索引分配
      const r = pixels[i * 4];
      const g = pixels[i * 4 + 1];
      const b = pixels[i * 4 + 2];
      const a = pixels[i * 4 + 3];
      
      // 非常简化的索引计算
      indexedPixels[i] = (r + g + b) % maxColors;
      
      // 如果是透明像素，使用最后一个索引（通常是透明色）
      if (a < 128) {
        indexedPixels[i] = maxColors - 1;
      }
    }
    
    return indexedPixels;
  }

  // 导出
  return imageQ;
})); 