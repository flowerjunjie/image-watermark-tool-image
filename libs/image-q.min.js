/**
 * image-q.min.js - Wrapper for browser compatibility
 * Version 4.0.0
 */
(function(root, factory) {
  // CommonJS / Node.js
  if (typeof module !== 'undefined' && typeof exports === 'object') {
    module.exports = factory();
  }
  // AMD / RequireJS
  else if (typeof define === 'function' && define.amd) {
    define([], factory);
  }
  // Browser globals (root is window)
  else {
    root.imageQ = factory();
  }
})(typeof self !== 'undefined' ? self : this, function() {
  'use strict';
  
  // Simple NeuQuantFloat implementation for browser
  class NeuQuantFloat {
    constructor(quality = 10) {
      this.quality = quality;
      this.colors = [];
      this._init();
    }
    
    _init() {
      // Create color palette - this is just a mock version
      // with 256 colors for demo purposes
      for (let i = 0; i < 256; i++) {
        this.colors.push({
          r: Math.floor(Math.random() * 256),
          g: Math.floor(Math.random() * 256),
          b: Math.floor(Math.random() * 256),
          a: 255
        });
      }
    }
    
    sample(r, g, b, a) {
      // In real implementation this would train the network
      // but for this simple mock we just store the colors
      this.colors.push({ r, g, b, a });
    }
    
    buildPalette() {
      // In real implementation, this would optimize the palette
      return this.colors.slice(0, 256);
    }
    
    reduce(pixels) {
      // Simple implementation that doesn't actually reduce properly
      // but works for demo purposes
      const output = new Uint8Array(pixels.length);
      
      for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i];
        const g = pixels[i + 1];
        const b = pixels[i + 2];
        const a = pixels[i + 3];
        
        let nearestColorIndex = 0;
        let nearestColorDistance = Number.MAX_VALUE;
        
        // Find closest color in palette (very inefficient)
        for (let j = 0; j < this.colors.length; j++) {
          const color = this.colors[j];
          const dr = color.r - r;
          const dg = color.g - g;
          const db = color.b - b;
          const da = color.a - a;
          
          // Simple Euclidean distance
          const distance = dr * dr + dg * dg + db * db + da * da;
          
          if (distance < nearestColorDistance) {
            nearestColorDistance = distance;
            nearestColorIndex = j;
          }
        }
        
        // Copy color
        output[i] = this.colors[nearestColorIndex].r;
        output[i + 1] = this.colors[nearestColorIndex].g;
        output[i + 2] = this.colors[nearestColorIndex].b;
        output[i + 3] = this.colors[nearestColorIndex].a;
      }
      
      return output;
    }
  }
  
  // Export minimal API needed by gifwrap
  return {
    NeuQuantFloat: NeuQuantFloat
  };
}); 