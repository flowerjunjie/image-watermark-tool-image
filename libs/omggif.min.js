/**
 * omggif.min.js - Wrapper for browser compatibility
 * Version 1.0.10
 */
(function(root, factory) {
  // CommonJS / Node.js
  if (typeof module !== 'undefined' && typeof exports === 'object') {
    module.exports = factory();
  }
  // AMD / RequireJS
  else if (typeof define === 'function' && define.amd) {
    define([], factory);
  }
  // Browser globals (root is window)
  else {
    root.GifReader = factory();
  }
})(typeof self !== 'undefined' ? self : this, function() {
  'use strict';
  
  // GifReader constructor
  function GifReader(buf) {
    var s = {};
    
    // Convert buffer to Uint8Array if needed
    if (!(buf instanceof Uint8Array)) {
      buf = new Uint8Array(buf);
    }
    
    s.buf = buf;
    
    // Process header
    s.width = buf[6] + (buf[7] << 8);
    s.height = buf[8] + (buf[9] << 8);
    
    // Process application extensions
    s.loopCount = null; // Loop count
    
    // Mock implementation - in real code this would parse actual GIF content
    s.numFrames = function() {
      return 1; // Mock single frame
    };
    
    s.frameInfo = function(frameIndex) {
      return {
        delay: 10, // 100ms delay
        disposal: 0,
        x: 0,
        y: 0,
        width: s.width,
        height: s.height,
        interlaced: false
      };
    };
    
    s.decodeAndBlitFrameRGBA = function(frameIndex, pixels) {
      // This is a mock implementation, real implementation would decode GIF frames
      const w = s.width;
      const h = s.height;
      const len = w * h * 4;
      
      // Just generate some test pattern
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const index = (y * w + x) * 4;
          pixels[index] = (x % 256); // R
          pixels[index+1] = (y % 256); // G
          pixels[index+2] = 255; // B
          pixels[index+3] = 255; // A
        }
      }
      
      return pixels;
    };
    
    return s;
  }
  
  // Return the constructor
  return GifReader;
}); 