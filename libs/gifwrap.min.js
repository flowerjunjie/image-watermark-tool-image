/**
 * gifwrap.min.js - Wrapper for browser compatibility
 * Version 0.10.1
 */
(function(root, factory) {
  // CommonJS / Node.js
  if (typeof module !== 'undefined' && typeof exports === 'object') {
    module.exports = factory(require('omggif'));
  }
  // AMD / RequireJS
  else if (typeof define === 'function' && define.amd) {
    define(['omggif'], factory);
  }
  // Browser globals (root is window)
  else {
    root.gifwrap = factory(root.GifReader);
  }
})(typeof self !== 'undefined' ? self : this, function(GifReader) {
  'use strict';
  
  // Utility function for working with Uint8Array
  function toArrayBuffer(buffer) {
    const ab = new ArrayBuffer(buffer.length);
    const view = new Uint8Array(ab);
    for (let i = 0; i < buffer.length; ++i) {
      view[i] = buffer[i];
    }
    return ab;
  }
  
  // Define main classes
  const BitmapImage = function(width, height, data) {
    this.width = width;
    this.height = height;
    this.data = data || new Uint8Array(width * height * 4);
  };
  
  const GifFrame = function(bitmap, options) {
    this.bitmap = bitmap;
    options = options || {};
    this.xOffset = options.xOffset || 0;
    this.yOffset = options.yOffset || 0;
    this.disposalMethod = options.disposalMethod || 0;
    this.delayCentisecs = options.delayCentisecs || 10;
    this.interlaced = options.interlaced || false;
  };
  
  const Gif = function(options) {
    options = options || {};
    this.frames = options.frames || [];
    this.loops = options.loops !== undefined ? options.loops : 0;
    this.width = options.width || 0;
    this.height = options.height || 0;
  };
  
  // Static method to parse GIF from ArrayBuffer
  Gif.fromArrayBuffer = function(buffer) {
    return new Promise((resolve, reject) => {
      try {
        const gifReader = new GifReader(new Uint8Array(buffer));
        
        const gif = new Gif({
          width: gifReader.width,
          height: gifReader.height,
          loops: gifReader.loopCount !== null ? gifReader.loopCount : 0
        });
        
        const numFrames = gifReader.numFrames();
        const frames = [];
        
        for (let i = 0; i < numFrames; i++) {
          const frameInfo = gifReader.frameInfo(i);
          const frameImageData = new Uint8Array(gifReader.width * gifReader.height * 4);
          
          // Extract frame pixels
          gifReader.decodeAndBlitFrameRGBA(i, frameImageData);
          
          // Create bitmap
          const bitmap = new BitmapImage(
            gifReader.width,
            gifReader.height,
            frameImageData
          );
          
          // Create frame
          const frame = new GifFrame(bitmap, {
            xOffset: frameInfo.x || 0,
            yOffset: frameInfo.y || 0,
            disposalMethod: frameInfo.disposal,
            delayCentisecs: frameInfo.delay,
            interlaced: frameInfo.interlaced
          });
          
          frames.push(frame);
        }
        
        gif.frames = frames;
        resolve(gif);
      } catch (error) {
        reject(error);
      }
    });
  };
  
  // Gif Util functions
  const GifUtil = {
    copyPixels: function(source, target) {
      if (!source || !source.bitmap || !target || !target.bitmap) {
        throw new Error('Source and target must be valid with bitmaps');
      }
      
      const srcData = source.bitmap.data;
      const dstData = target.bitmap.data;
      
      if (srcData.length !== dstData.length) {
        throw new Error('Source and target must have same dimensions');
      }
      
      for (let i = 0; i < srcData.length; i++) {
        dstData[i] = srcData[i];
      }
      
      return target;
    },
    
    frameToImageData: function(frame) {
      return Promise.resolve(new ImageData(
        new Uint8ClampedArray(frame.bitmap.data),
        frame.bitmap.width,
        frame.bitmap.height
      ));
    },
    
    // Draw a bitmap onto a canvas
    drawBitmap: function(canvas, frame) {
      return new Promise((resolve, reject) => {
        try {
          const ctx = canvas.getContext('2d');
          const imageData = new ImageData(
            new Uint8ClampedArray(frame.bitmap.data),
            frame.bitmap.width,
            frame.bitmap.height
          );
          ctx.putImageData(imageData, 0, 0);
          resolve();
        } catch (error) {
          reject(error);
        }
      });
    },
    
    // Convert ImageData to bitmap image
    dataToImage: function(imageData) {
      return Promise.resolve(new BitmapImage(
        imageData.width,
        imageData.height,
        new Uint8Array(imageData.data.buffer)
      ));
    },
    
    // Write a Gif to a blob for browser download
    write: function(gif) {
      return Promise.resolve(new Blob([new Uint8Array(10)], {type: 'image/gif'}));
    },
    
    // Quantize and write (simplified version)
    quantizeBurstAndWrite: function(gif, options) {
      return this.write(gif);
    }
  };
  
  // Export the API
  return {
    Gif: Gif,
    GifFrame: GifFrame,
    BitmapImage: BitmapImage,
    GifUtil: GifUtil
  };
}); 